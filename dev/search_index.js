var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Modules = [Simulation]\nPrivate = true","category":"page"},{"location":"api/#Simulation.AlwaysMovement","page":"API","title":"Simulation.AlwaysMovement","text":"AlwaysMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nMovement can happen to any individual (\"animal-like\").\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.BirthOnlyMovement","page":"API","title":"Simulation.BirthOnlyMovement","text":"BirthOnlyMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nMovement can only happen to individuals that have just been born (\"plant-like\").\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.CachedEcosystem","page":"API","title":"Simulation.CachedEcosystem","text":"CachedEcosystem{Part <: AbstractAbiotic, SL <: SpeciesList,\n    TR <: AbstractTraitRelationship} <: AbstractEcosystem{Part, SL, TR}\n\nCachedEcosystem houses the same information as Ecosystem (see ?Ecosystem), but holds the time period abundances as a CachedGridLandscape, so that they may be present or missing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.CachedEcosystem-Tuple{Ecosystem,String,StepRangeLen}","page":"API","title":"Simulation.CachedEcosystem","text":"CachedEcosystem(eco::Ecosystem, outputfile::String, rng::StepRangeLen)\n\nFunction to create a CachedEcosystem given an existing ecosystem, eco, output folder to which the simulations are saved, outputfile, and a range of times over which to simulate, rng.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.CachedGridLandscape","page":"API","title":"Simulation.CachedGridLandscape","text":"CachedGridLandscape\n\nEcosystem abundances housed in the cached landscape. These are either stored in the matrix or output to a cache.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Cylinder","page":"API","title":"Simulation.Cylinder","text":"Cylinder <: BoundaryCondition\n\nA cylindrical boundary where species can cross the x boundary but not the y.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.DiscreteHab","page":"API","title":"Simulation.DiscreteHab","text":"DiscreteHab <: AbstractHabitat{String}\n\nThis habitat subtype has a matrix of strings and a float grid square size\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.DiscreteTrait","page":"API","title":"Simulation.DiscreteTrait","text":"BasicTrait{T} <: AbstractTraits{T}\n\nBasic trait type that holds information on a single trait for each species, of any type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Ecosystem","page":"API","title":"Simulation.Ecosystem","text":"Ecosystem{Part <: AbstractAbiotic} <:\n   AbstractEcosystem{Part, SL, TR}\n\nEcosystem houses information on species and their interaction with their environment. For species, it holds abundances and locations, abundances, as well as properties such as trait information, spplist, and movement types, lookup. For environments, it provides information on environmental conditions and available resources,abenv. Finally, there is a slot for the relationship between the environment and the characteristics of the species, relationship.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Ecosystem-Union{Tuple{Req}, Tuple{T}, Tuple{F}, Tuple{F,SpeciesList{T,Req,MO,T1,P} where P<:Simulation.AbstractParams where T1<:Diversity.API.AbstractTypes where MO<:Simulation.AbstractMovement,GridAbioticEnv,Simulation.AbstractTraitRelationship}} where Req where T where F<:Function","page":"API","title":"Simulation.Ecosystem","text":"Ecosystem(spplist::SpeciesList, abenv::GridAbioticEnv,\n    rel::AbstractTraitRelationship)\n\nFunction to create an Ecosystem given a species list, an abiotic environment and trait relationship. An optional population function can be added, popfun, which defaults to generic random filling of the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.EpiLandscape","page":"API","title":"Simulation.EpiLandscape","text":"EpiLandscape\n\nDisease class abundances housed in the landscape. These are represented in both 2 dimensions (for computational efficiency in simulations) and 3 dimensions (to represent disease classes, their abundances and position in the grid).\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.EpiList","page":"API","title":"Simulation.EpiList","text":"EpiList{P <: AbstractParams} <: AbstractTypes\n\nEpi list houses all disease and virus class specific information, as well as parameters for model runs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.EpiList-Union{Tuple{P}, Tuple{MO}, Tuple{TR}, Tuple{TR,NamedTuple,NamedTuple,NamedTuple,MO,P}, Tuple{TR,NamedTuple,NamedTuple,NamedTuple,MO,P,Int64}} where P<:Simulation.AbstractParams where MO<:Simulation.AbstractMovement where TR<:Simulation.AbstractTraits","page":"API","title":"Simulation.EpiList","text":"EpiList(traits::TR, virus_abun::NamedTuple, human_abun::NamedTuple, disease_classes::NamedTuple, movement::MO, param::P, age_categories::Int64 = 1) where {TR <: AbstractTraits, MO <: AbstractMovement, P <: AbstractParams}\n\nFunction to create an EpiList for any type of epidemiological model - creating the correct number of classes and checking dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.EpiSystem","page":"API","title":"Simulation.EpiSystem","text":"EpiSystem{EE <: AbstractEpiEnv, EL <: EpiList, ER <: AbstractRelationship} <: AbstractEpiSystem{EE, EL, ER}\n\nEpiSystem houses information on different disease classes, epilist, the environment, epienv, and their relationship to one another, relationship.\n\nSee help?>plot_epidynamics and help?>plot_epiheatmaps for relevant plotting functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.EqualPop","page":"API","title":"Simulation.EqualPop","text":"EqualPop <: AbstractParams\n\nParameter type that holds information on a population's birth and death rates, birth and death, specifically populations where all species have the same information. l represents the longevity of species based on their energy requirements and s is the survival of species dependent on how well their traits reflect the environment. Finally boost is used to manipulate how much of a boost the species get from being in an environment with lots of available energy.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.FluctScenario","page":"API","title":"Simulation.FluctScenario","text":"FluctScenario <: AbstractScenario\n\nThis scenario type holds a function that acts to fluctuate the environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Gauss","page":"API","title":"Simulation.Gauss","text":"Gauss{TR} <: AbstractTraitRelationship{TR}\n\nThe Gaussian relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.GaussTrait","page":"API","title":"Simulation.GaussTrait","text":"GaussTrait{C <: Number} <: ContinuousTrait{C}\n\nTrait type that holds Gaussian mean and variance trait information for each species, of any number type C.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.GaussianKernel","page":"API","title":"Simulation.GaussianKernel","text":"GaussianKernel <: AbstractKernel\n\nGaussianMovement holds parameters for a gaussian movement kernel; a dispersal variance for a species, var, and a threshold, thresh, beyond which dispersal cannot take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.GridAbioticEnv","page":"API","title":"Simulation.GridAbioticEnv","text":"GridAbioticEnv{H, B} <: AbstractAbiotic{H, B}\n\nThis abiotic environment type holds a habitat and budget, as well as a string of subcommunity names.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.GridEpiEnv","page":"API","title":"Simulation.GridEpiEnv","text":"GridEpiEnv{H, C} <: AbstractAbiotic{H, C}\n\nThis epi environment type holds a habitat and control strategy, as well as a string of subcommunity names, and initial susceptible population.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.GridLandscape","page":"API","title":"Simulation.GridLandscape","text":"GridLandscape\n\nEcosystem abundances housed in the landscape. These are represented in both 2 dimensions (for computational efficiency in simulations) and 3 dimensions (to represent species, their abundances and position in the grid).\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.LongTailKernel","page":"API","title":"Simulation.LongTailKernel","text":"LongTailKernel <: AbstractKernel\n\nLongTailKernel holds parameters for a movement kernel; a dispersal variance for a species, var, and a threshold, thresh, beyond which dispersal cannot take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Match","page":"API","title":"Simulation.Match","text":"Match{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a discrete trait and its environment, paramaterised on any TR. Current conditions are matched to a trait preference and checked for a match.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.MultiScenario","page":"API","title":"Simulation.MultiScenario","text":"MultiScenario{S1 <: AbstractScenario, S2 <: AbstractScenario} <: AbstractScenario\n\nThis scenario type holds multiple different scenario types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.NoBoundary","page":"API","title":"Simulation.NoBoundary","text":"NoBoundary <: BoundaryCondition\n\nA hard boundary where no species can cross.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.NoControl","page":"API","title":"Simulation.NoControl","text":"NoControl <: AbstractControl\n\nDefault strategy, which implements no control measures.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.NoMovement","page":"API","title":"Simulation.NoMovement","text":"NoMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nNo movement can take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.NoRelContinuous","page":"API","title":"Simulation.NoRelContinuous","text":"NoRelContinuous{TR} <: AbstractTraitRelationship{TR}\n\nThe absense of a relationship between a continuous trait and its environment, paramaterised on any TR. Returns the value 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.NoRelDiscrete","page":"API","title":"Simulation.NoRelDiscrete","text":"NoRelDiscrete{TR} <: AbstractTraitRelationship{TR}\n\nThe absense of a relationship between a discrete trait and its environment, paramaterised on any TR. Returns the value 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.PopGrowth","page":"API","title":"Simulation.PopGrowth","text":"PopGrowth <: AbstractParams\n\nBasic parameter type that holds information on a population's birth and death rates, birth and death, as well as how these are altered by energy availability. l represents the longevity of species based on their energy requirements and s is the survival of species dependent on how well their traits reflect the environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.RainBin","page":"API","title":"Simulation.RainBin","text":"RainBin{C <: Int} <: ContinuousTrait{C}\n\nTrait type that holds binned rainfall preference information created through ClimatePref. Holds an array of counts per rainfall band (mm).\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SEI2HRDGrowth","page":"API","title":"Simulation.SEI2HRDGrowth","text":"SEI2HRDGrowth{U <: Unitful.Units} <: AbstractParams\n\nParameter set that houses information on birth and death rates of different classes in an SEI2HRD model, as well as growth and decay of virus, and infection/incubation/hospitalisation/recovery parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SEI2HRDGrowth-Union{Tuple{U}, Tuple{Array{Unitful.Quantity{Float64,ð“^-1,U},1},Array{Unitful.Quantity{Float64,ð“^-1,U},1},Unitful.Quantity{Float64,ð“^-1,U},Unitful.Quantity{Float64,ð“^-1,U},Unitful.Quantity{Float64,ð“^-1,U},Unitful.Quantity{Float64,ð“^-1,U},Unitful.Quantity{Float64,ð“^-1,U},Float64,Float64,Float64,Float64,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}} where U<:Unitful.Units","page":"API","title":"Simulation.SEI2HRDGrowth","text":"SEI2HRDGrowth(birth::Vector{TimeUnitType{U}},     death::Vector{TimeUnitType{U}}, beta::TimeUnitType{U}, probsym::Float64, probhosp::Float64, casefatalityratio::Float64, Tlat::Unitful.Time, Tasym::Unitful.Time, Tsym::Unitful.Time, Thosp::Unitful.Time, T_rec::Unitful.Time) where {U <: Unitful.Units}\n\nFunction to calculate SEI2HRD parameters from initial probabilities of developing symptoms and needing hospitalisation, case fatality ratio, and time for transition between different categories.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.SEI3HRDGrowth","page":"API","title":"Simulation.SEI3HRDGrowth","text":"SEI3HRDGrowth{U <: Unitful.Units} <: AbstractParams\n\nParameter set that houses information on birth and death rates of different classes in an SEI3HRD model, as well as growth and decay of virus, and infection/incubation/hospitalisation/recovery parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SEIRGrowth","page":"API","title":"Simulation.SEIRGrowth","text":"SEIRGrowth{U <: Unitful.Units} <: AbstractParams\n\nParameter set that houses information on birth and death rates of different classes in an SEIR model, as well as growth and decay of virus, and infection/incubation/recovery parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SEIRSGrowth","page":"API","title":"Simulation.SEIRSGrowth","text":"SEIRSGrowth{U <: Unitful.Units} <: AbstractParams\n\nParameter set that houses information on birth and death rates of different classes in an SEIRS model, as well as growth and decay of virus, and infection/incubation/recovery parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SIRGrowth","page":"API","title":"Simulation.SIRGrowth","text":"SIRGrowth{U <: Unitful.Units} <: AbstractParams\n\nParameter set that houses information on birth and death rates of different classes in an SIR model, as well as growth and decay of virus, and infection/recovery parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SISGrowth","page":"API","title":"Simulation.SISGrowth","text":"SISGrowth{U <: Unitful.Units} <: AbstractParams\n\nParameter set that houses information on birth and death rates of different classes in an SIS model, as well as growth and decay of virus, and infection/recovery parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SimpleBudget","page":"API","title":"Simulation.SimpleBudget","text":"SimpleBudget <: AbstractBudget{Float64}\n\nThis budget type has a matrix of floats, representing the energy budget of each subcommunity in the abiotic environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SimpleRequirement","page":"API","title":"Simulation.SimpleRequirement","text":"SimpleRequirement <: Abstract1Requirement{Float64}\n\nA simple energy requirement is a single float for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SimpleScenario","page":"API","title":"Simulation.SimpleScenario","text":"SimpleScenario <: AbstractScenario\n\nThis scenario type holds a function that acts to change the entire ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SizeRequirement","page":"API","title":"Simulation.SizeRequirement","text":"SizeRequirement <: Abstract1Requirement{Float64}\n\nA simple energy requirement is a single float for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SolarBudget","page":"API","title":"Simulation.SolarBudget","text":"SolarBudget <: AbstractBudget{typeof(1.0*kJ)}\n\nThis budget type has a matrix of solar energy units, representing the energy budget of each subcommunity in the abiotic environment at a fixed point in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SolarRequirement","page":"API","title":"Simulation.SolarRequirement","text":"SolarRequirement <: Abstract1Requirement{typeof(1.0*kJ)}\n\nA vector of solar energy requirements (kJ) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SolarTimeBudget","page":"API","title":"Simulation.SolarTimeBudget","text":"SolarTimeBudget <: AbstractBudget{typeof(1.0*kJ)}\n\nThis budget type has a matrix of solar energy units, representing the energy budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SpeciesList","page":"API","title":"Simulation.SpeciesList","text":"SpeciesList{TR <: AbstractTraits, R <: AbstractRequirement,\n            MO <: AbstractMovement, T <: AbstractTypes,\n            P <: AbstractParams} <: AbstractTypes\n\nSpecies list houses all species-specific information including trait information, phylogenetic relationships, requirement for energy and movement types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.SpeciesList-Union{Tuple{P}, Tuple{MO}, Tuple{R}, Tuple{Int64,Int64,Array{Int64,1},R,MO,P,Array{Bool,1},Array{Float64,1}}} where P<:Simulation.AbstractParams where MO<:Simulation.AbstractMovement where R<:Simulation.AbstractRequirement","page":"API","title":"Simulation.SpeciesList","text":"SpeciesList{R <: AbstractRequirement,\n  MO <: AbstractMovement, P <: AbstractParams}(numspecies::Int64,\n  numtraits::Int64, abun_dist::Distribution, req::R,\n  movement::MO, params::P)\n\nFunction to create a SpeciesList given a number of species, the number of traits they possess, their abundances, requirement from the environment and their movement kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.SpeciesList-Union{Tuple{P}, Tuple{T}, Tuple{MO}, Tuple{R}, Tuple{Int64,Int64,Array{Int64,1},R,MO,T,P,Array{Bool,1}}} where P<:Simulation.AbstractParams where T<:Diversity.API.AbstractTypes where MO<:Simulation.AbstractMovement where R<:Simulation.AbstractRequirement","page":"API","title":"Simulation.SpeciesList","text":"SpeciesList{R <: AbstractRequirement, MO <: AbstractMovement,\n  T <: AbstractTypes, P <: AbstractParams}(numspecies::Int64,\n  numtraits::Int64, abun_dist::Distribution, req::R,\n  movement::MO, phy::T, params::P)\n\nFunction to create a SpeciesList given a number of species, the number of traits they possess, their abundances, requirement from the environment and their movement kernel and any type of AbstractTypes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.TempBin","page":"API","title":"Simulation.TempBin","text":"TempBin{C <: Int} <: ContinuousTrait{C}\n\nTrait type that holds binned temperature preference information created through ClimatePref. Holds an array of counts per temperature band (Â°C).\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Torus","page":"API","title":"Simulation.Torus","text":"Torus <: BoundaryCondition\n\nA toroidal boundary where species can cross both boundaries.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.TraitCollection2","page":"API","title":"Simulation.TraitCollection2","text":"TraitCollection2{T1, T2} <: AbstractTraits{Tuple{T1, T2}}\n\nTrait collection that holds two trait types, TR1 and TR2.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.TraitCollection3","page":"API","title":"Simulation.TraitCollection3","text":"TraitCollection3{T1, T2, T3} <: AbstractTraits{Tuple{T1, T2, T3}}\n\nTrait collection that holds three trait types, TR1, TR2 and TR3.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Trapeze","page":"API","title":"Simulation.Trapeze","text":"Trapeze{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Trapezoid","page":"API","title":"Simulation.Trapezoid","text":"Trapezoid{T<:Real} <: ContinuousUnivariateDistribution\n\nTrapezoidal distribution as described at https://en.wikipedia.org/wiki/Trapezoidal_distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Unif","page":"API","title":"Simulation.Unif","text":"Trapeze{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.VolWaterRequirement","page":"API","title":"Simulation.VolWaterRequirement","text":"VolWaterRequirement <: Abstract1Requirement{typeof(1.0*mm)}\n\nA vector of soil water volume requirements (m^3) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.VolWaterTimeBudget","page":"API","title":"Simulation.VolWaterTimeBudget","text":"VolWaterTimeBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of volumetric soil water units, representing the water budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.WaterRequirement","page":"API","title":"Simulation.WaterRequirement","text":"WaterRequirement <: Abstract1Requirement{typeof(1.0*mm)}\n\nA vector of water requirements (mm) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.WaterTimeBudget","page":"API","title":"Simulation.WaterTimeBudget","text":"WaterTimeBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of rainfall units, representing the water budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.additiveTR2","page":"API","title":"Simulation.additiveTR2","text":"additiveTR2{TR1, TR2} <: AbstractTraitRelationship{Tuple{TR1, TR2}}\n\nType that houses multiple AbstractTraitRelationships for two trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.additiveTR3","page":"API","title":"Simulation.additiveTR3","text":"multiplicativeTR3{TR1, TR2, TR3} <: AbstractTraitRelationship{Tuple{TR1, TR2, TR3}}\n\nType that houses multiple AbstractTraitRelationships for three trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.multiplicativeTR2","page":"API","title":"Simulation.multiplicativeTR2","text":"multiplicativeTR2{TR1, TR2} <: AbstractTraitRelationship{Tuple{TR1, TR2}}\n\nType that houses multiple AbstractTraitRelationships for two trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.multiplicativeTR3","page":"API","title":"Simulation.multiplicativeTR3","text":"multiplicativeTR3{TR1, TR2, TR3} <: AbstractTraitRelationship{Tuple{TR1, TR2, TR3}}\n\nType that houses multiple AbstractTraitRelationships for three trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.ContinuousEvolve-Tuple{Union{Float64, Unitful.Quantity{Float64,D,U} where U where D},Union{Float64, Unitful.Quantity{Float64,D,U} where U where D},Phylo.BinaryTree}","page":"API","title":"Simulation.ContinuousEvolve","text":"ContinuousEvolve(val::Union{Float64, Unitful.Quantity{Float64}}, var::Union{Float64, Unitful.Quantity{Float64}}, tree::BinaryTree)\n\nFunction to evolve a continuous trait along a BinaryTree, tree via Brownian motion. Takes in a starting value, val and a variance, var.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.DiscreteEvolve","page":"API","title":"Simulation.DiscreteEvolve","text":"DiscreteEvolve(numTraits::Int64, tree::BinaryTree)\n\nFunction to evolve a discrete switching trait along a BinaryTree, tree. Takes in a number of traits, numTraits to be switched between and rate to switch between traits, switch_rate with default value of 0.5.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.SIR_wrapper!-Tuple{Tuple{Int64,Int64},Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,NamedTuple,NamedTuple,Array{Int64,3}}","page":"API","title":"Simulation.SIR_wrapper!","text":"SIR_wrapper!(grid_size::Tuple{Int64, Int64}, area::Unitful.Area{Float64}, params::NamedTuple, runtimes::NamedTuple, abuns::Array{Int64, 3})\n\nFunction to simulate simple SIR stochastic realisations, given a grid dimension, grid_size, area size, a set of model parameters, params, and running parameters, runtimes.\n\nFills an abundance matrice of compartment by grid cell over time. Compartments for the SIR model are: Susceptible, Infected, Recovered, Dead.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.SIR_wrapper-Tuple{Tuple{Int64,Int64},Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,NamedTuple,NamedTuple}","page":"API","title":"Simulation.SIR_wrapper","text":"SIR_wrapper(grid_size::Tuple{Int64, Int64}, area::Unitful.Area{Float64}, params::NamedTuple, runtimes::NamedTuple)\n\nFunction to simulate simple SIR stochastic realisations, given a grid dimension, grid_size, area size, a set of model parameters, params, and running parameters, runtimes.\n\nOutputs an abundance matrice of compartment by grid cell over time. Compartments for the SIR model are: Susceptible, Infected, Recovered, Dead.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.TempChange-Tuple{Simulation.AbstractEcosystem,ContinuousHab,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.TempChange","text":"TempChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to increase the temperature for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.TempFluct-Tuple{Simulation.AbstractEcosystem,ContinuousHab,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.TempFluct","text":"TempFluct(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to fluctuate the temperature for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.abundances-Tuple{CachedEcosystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.abundances","text":"abundances(cache::CachedEcosystem, tm::Unitful.Time)\n\nFunction to extract abundances for an ecosystem, cache, at a certain point in time, tm. If the abundances for that time are missing from the ecosystem, then the function checks on disk for the last saved version and simulates forward.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.assign_traits!-Tuple{Phylo.BinaryTree,Array{Float64,1},DataFrames.DataFrame}","page":"API","title":"Simulation.assign_traits!","text":"assign_traits!(tree::BinaryTree, switch_rate::Vector{Float64},\ntraits::Vector{Vector{String}})\n\nFunction to evolve categorical functional traits through a phylogenetic tree with a specific switching rate.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.assign_traits!-Tuple{Phylo.BinaryTree,DataFrames.DataFrame}","page":"API","title":"Simulation.assign_traits!","text":"assign_traits!(tree::BinaryTree, start::Vector{Float64},\n  ÏƒÂ²::Vector{Float64})\n\nFunction to evolve continuous functional traits through a phylogenetic tree through Brownian motion, with a starting value, start, and rate, ÏƒÂ².\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.convert_coords","page":"API","title":"Simulation.convert_coords","text":"convert_coords(eco, i::Int64, width::Int64)\nconvert_coords(eco, x::Int64, y::Int64, width::Int64)\n\nFunction to convert coordinates from two-dimensional (x,y) format to one dimension (i), or vice versa, using the width of the grid. This function can also be applied to arrays of coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.emptypopulate!-Union{Tuple{R}, Tuple{AB}, Tuple{GridLandscape,SpeciesList,AB,R}} where R<:Simulation.AbstractTraitRelationship where AB<:Simulation.AbstractAbiotic","page":"API","title":"Simulation.emptypopulate!","text":"emptypopulate!(ml::GridLandscape, spplist::SpeciesList,\n               abenv::AB, rel::R) where {AB <: Simulation.AbstractAbiotic, R <: Simulation.AbstractTraitRelationship}\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.eraAE-Tuple{Simulation.ClimatePref.ERA,Unitful.Quantity{Float64,D,U} where U where D}","page":"API","title":"Simulation.eraAE","text":"eraAE(era::ERA, maxbud::Unitful.Quantity{Float64})\n\nFunction to create a ContinuousHab, SimpleBudget type abiotic environment from an ERA type climate. It either creates a SimpleBudget type filled with the maximum budget value maxbud or uses a provided budget of type SolarTimeBudget. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.eraChange-Tuple{Simulation.AbstractEcosystem,ContinuousTimeHab,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.eraChange","text":"eraChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to step the ERA climate forward by one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.geom_mean_abun-Tuple{Ecosystem,Array{Float64,1}}","page":"API","title":"Simulation.geom_mean_abun","text":"geom_mean_abun(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the geometric mean abundance for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.get_neighbours","page":"API","title":"Simulation.get_neighbours","text":"get_neighbours(mat::Matrix, x_coord::Int64, y_coord::Int64, chess::Int64=4)\n\nFunction to get the neighbours of a grid square in a matrix in 4 or 8 directions\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.get_traits","page":"API","title":"Simulation.get_traits","text":"get_traits(tree::BinaryTree, tips::Bool=true)\n\nFunction to retrieve functional traits assigned to a phylogenetic tree, either just tips or all nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.getbudget-Tuple{Simulation.AbstractEcosystem}","page":"API","title":"Simulation.getbudget","text":"getbudget(eco::Ecosystem)\n\nFunction to extract budget from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.getdispersaldist-Tuple{Simulation.AbstractEcosystem,Int64}","page":"API","title":"Simulation.getdispersaldist","text":"getdispersaldist(eco::Ecosystem)\n\nFunction to extract average dispersal distance of species from Ecosystem object. Returns a vector of distances, unless a specific species is provided as a String or Integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.getdispersalvar-Tuple{Simulation.AbstractEcosystem,Int64}","page":"API","title":"Simulation.getdispersalvar","text":"getdispersalvar(eco::Ecosystem)\n\nFunction to extract dispersal varaince of species from Ecosystem object. Returns a vector of distances, unless a specific species is provided as a String or Integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.getgridsize-Tuple{Simulation.AbstractEcosystem}","page":"API","title":"Simulation.getgridsize","text":"getgridsize(eco::Ecosystem)\n\nFunction to extract grid cell size of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.gethabitat-Tuple{Simulation.AbstractEcosystem}","page":"API","title":"Simulation.gethabitat","text":"gethabitat(eco::Ecosystem)\n\nFunction to extract habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.getpref-Union{Tuple{T}, Tuple{T,Symbol}} where T<:Simulation.AbstractTraits","page":"API","title":"Simulation.getpref","text":"getpref(traits::T, field::Symbol) where T <: AbstractTraits\n\nFunction to extract trait preferences for all species in the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.getsize-Tuple{Simulation.AbstractEcosystem}","page":"API","title":"Simulation.getsize","text":"getsize(eco::Ecosystem)\n\nFunction to extract size of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.gettraitrel-Tuple{Simulation.AbstractEcosystem}","page":"API","title":"Simulation.gettraitrel","text":"gettraitrel(eco::Ecosystem)\n\nFunction to extract trait relationships.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.makeunique-Tuple{Ecosystem}","page":"API","title":"Simulation.makeunique","text":"makeunique(eco::Ecosystem)\n\nFunction to convert type of similarity in SpeciesList to UniqueTypes, i.e. an identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.mean_abun-Tuple{Ecosystem,Array{Float64,1}}","page":"API","title":"Simulation.mean_abun","text":"mean_abun(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the mean arithmetic abundance for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.meta_shannon-Tuple{Ecosystem,Array{Float64,1}}","page":"API","title":"Simulation.meta_shannon","text":"meta_shannon(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Shannon entropy for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.meta_simpson-Tuple{Ecosystem,Array{Float64,1}}","page":"API","title":"Simulation.meta_simpson","text":"meta_simpson(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Simpson diversity for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.meta_speciesrichness-Tuple{Ecosystem,Array{Float64,1}}","page":"API","title":"Simulation.meta_speciesrichness","text":"meta_speciesrichness(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the species richness for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.parse_hdf5-Tuple{Any}","page":"API","title":"Simulation.parse_hdf5","text":"parse_hdf5(path; grid=\"10k\", component=\"scotland_2018\")\n\nParse HDF5-format file at path, containing component. The data is read on a grid with cells of size grid meters x grid meters and ages are assumed to be binned into 5 years intervals, starting at zero and going up to 90+.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.pd-Tuple{Ecosystem,Array{Float64,1}}","page":"API","title":"Simulation.pd","text":"pd(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate Faith's phylogenetic diversity (PD) for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.peakedgradAE-Tuple{Union{Unitful.Quantity{Float64,ðš¯,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ðš¯,U}} where S where L} where U,Union{Unitful.Quantity{Float64,ðš¯,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ðš¯,U}} where S where L} where U,Tuple{Int64,Int64},Unitful.Quantity{Float64,D,U} where U where D,Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,Unitful.Quantity{Float64,ðš¯*ð“^-1,U} where U,Array{Bool,2}}","page":"API","title":"Simulation.peakedgradAE","text":"peakedgradAE(minT::Unitful.Temperature{Float64},\n   maxT::Unitful.Temperature{Float64},\n   dimension::Tuple{Int64, Int64}, maxbud::Unitful.Quantity{Float64},\n   area::Unitful.Area{Float64}, rate::Quantity{Float64, ðš¯*ð“^-1},\n   active::Array{Bool, 2})\n\nFunction to create a temperature gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max temperature, it generates a gradient from minima at the top and bottom peaking to maximum in the middle. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.plot_epidynamics","page":"API","title":"Simulation.plot_epidynamics","text":"plot_epidynamics(\n    epi::AbstractEpiSystem,\n    abuns::AbstractArray{<:Integer, 3};\n    category_map=nothing,\n)\n\nPlot the dynamics of abuns summed over space, as a function of time.\n\nArguments\n\nepi: The AbstractEpiSystem to plot.\nabuns: The array of abundances to plot, of size Ncompartments x Ncells x Nsteps\n\nKeyword arguments\n\ncategory_map: An iterable of key-value pairs where the keys are category names, and the   values are a list of compartment indices associated with that category. These   compartments will be summed in the plot. For example, the following will plot the sum of   compartments 1 and 2 as the Susceptible category, and the sum of compartments 3 and 4   as the Infected category.\n  category_map = (\"Susceptible\" => [1, 2], \"Infected\" => [3, 4])\nIf category_map is nothing, all compartments in epi will be plotted separately   with their corresponding names.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.plot_epiheatmaps","page":"API","title":"Simulation.plot_epiheatmaps","text":"plot_epiheatmaps(\n    epi::AbstractEpiSystem,\n    abuns::AbstractArray{<:Integer, 3};\n    compartment=\"Exposed\",\n    steps=[],\n)\n\nPlot heatmaps of abuns for compartment at steps.\n\nArguments\n\nepi: The AbstractEpiSystem to plot.\nabuns: The array of abundances to plot, of size Ncompartments x Ncells x Nsteps\n\nKeyword arguments\n\ncompartment: The compartment to plot\nsteps: A list of steps to plot (one heatmap for each step). If empty, plots 4   equally-spaced steps.\n\nnote: Note\nHeatmaps are transposed by default. Pass in transpose=false to turn this off.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.populate!-Union{Tuple{R}, Tuple{EE}, Tuple{EpiLandscape,EpiList,EE,R}} where R<:Simulation.AbstractTraitRelationship where EE<:Simulation.AbstractEpiEnv","page":"API","title":"Simulation.populate!","text":"populate!(ml::EpiLandscape, epilist::EpiList, epienv::EE, rel::R)\n\nFunction to populate an EpiLandscape with information on each disease class in the EpiList.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.raingrad-Tuple{Union{Unitful.Quantity{Float64,ð‹,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹,U}} where S where L} where U,Union{Unitful.Quantity{Float64,ð‹,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹,U}} where S where L} where U,Union{Unitful.Quantity{Float64,ð‹,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹,U}} where S where L} where U,Tuple{Int64,Int64},Unitful.Quantity{Float64,ð‹*ð“^-1,U} where U}","page":"API","title":"Simulation.raingrad","text":"raingrad(minT::Unitful.Temperature{Float64}, maxT::Unitful.Temperature{Float64},\n  size::Unitful.Length{Float64},\n  dim::Tuple{Int64, Int64}, rate::Quantity{Float64, ðš¯*ð“^-1})\n\nFunction to create a ContinuousHab habitat with a rainfall gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.raingradAE-Tuple{Union{Unitful.Quantity{Float64,ð‹,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹,U}} where S where L} where U,Union{Unitful.Quantity{Float64,ð‹,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹,U}} where S where L} where U,Tuple{Int64,Int64},Unitful.Quantity{Float64,D,U} where U where D,Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,Unitful.Quantity{Float64,ð‹*ð“^-1,U} where U,Array{Bool,2}}","page":"API","title":"Simulation.raingradAE","text":"raingradAE(min::Unitful.Temperature{Float64},\n  max::Unitful.Temperature{Float64},\n  dimension::Tuple{Int64, Int64}, maxbud::Float64,\n  area::Unitful.Area{Float64}, rate::Quantity{Float64, typeof(ðš¯*ð“^-1)},\n  active::Array{Bool, 2})\n\nFunction to create a rain gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max rainfall, it generates a gradient from minimum at the bottom to maximum at the top. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of rainfall change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.randomniches-Tuple{Tuple,Array{Int64,1},Float64,Array{T,1} where T,Union{Unitful.Quantity{T,ð‹,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð‹,U}} where S where L} where U where T}","page":"API","title":"Simulation.randomniches","text":"randomniches(dimension::Tuple, types::Vector{String}, clumpiness::Float64, weights::Vector)\n\nFunction to create a DiscreteHab habitat of dimension dimension, made up of sampled string types, types, that have a weighting, weights and clumpiness parameter, clumpiness.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.reenergise!-Tuple{Ecosystem,Union{Float64, Unitful.Quantity{Float64,D,U} where U where D},Tuple{Int64,Int64}}","page":"API","title":"Simulation.reenergise!","text":"reenergise!(eco::Ecosystem, budget::Union{Float64, Unitful.Quantity{Float64}}, grid::Tuple{Int64, Int64})\n\nFunction to refill an ecosystem eco, with energy from a budget value, budget and a grid size.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.repopulate!-Tuple{Ecosystem}","page":"API","title":"Simulation.repopulate!","text":"repopulate!(eco::Ecosystem, abun::Int64)\n\nFunction to repopulate an ecosystem eco, with option for including trait preferences. An additional abun parameter can be included, in order to repopulate the ecosystem with a specified number of individuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.resetrate!-Tuple{Simulation.AbstractEcosystem,Unitful.Quantity{Float64,Unitful.Dimensions{(Unitful.Dimension{:Time}(-1//1),)},U} where U}","page":"API","title":"Simulation.resetrate!","text":"resetrate!(eco::Ecosystem, rate::Quantity{Float64, typeof(ð“^-1)})\n\nFunction to reset the rate of habitat change for a species.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simplehabitatAE-Tuple{Union{Float64, Unitful.Quantity{Float64,D,U} where U where D},Tuple{Int64,Int64},Unitful.Quantity{Float64,D,U} where U where D,Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,Array{Bool,2}}","page":"API","title":"Simulation.simplehabitatAE","text":"simplehabitatAE(val::Union{Float64, Unitful.Quantity{Float64}},\n    dimension::Tuple{Int64, Int64}, maxbud::Float64, area::Unitful.Area{Float64},\n    active::Array{Bool, 2})\n\nFunction to create a simple ContinuousHab, SimpleBudget type abiotic environment. It creates a ContinuousHab filled with a given value, val, dimensions (dimension) and a specified area (area). It also creates a SimpleBudget type filled with the maximum budget value (maxbud). The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simplehabitatAE-Union{Tuple{C}, Tuple{Union{Float64, Unitful.Quantity{Float64,D,U} where U where D},Tuple{Int64,Int64},Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,AbstractArray{Bool,2},C}, Tuple{Union{Float64, Unitful.Quantity{Float64,D,U} where U where D},Tuple{Int64,Int64},Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,AbstractArray{Bool,2},C,AbstractArray{#s188,2} where #s188<:Integer}} where C<:Simulation.AbstractControl","page":"API","title":"Simulation.simplehabitatAE","text":"function simplehabitatAE(\n    val::Union{Float64, Unitful.Quantity{Float64}},\n    dimension::Tuple{Int64, Int64},\n    area::Unitful.Area{Float64},\n    active::AbstractMatrix{Bool},\n    control::C,\n    initial_population::AbstractMatrix{<:Integer}=zeros(Int, dimension),\n)\n\nFunction to create a simple ContinuousHab type epi environment. It creates a ContinuousHab filled with a given value val, of dimensions dimension and specified area area. If a Bool matrix active of active grid squares is included, this is used, else one is created with all grid cells active.\n\nnote: Note\nThe simulation grid will be shrunk so that it tightly wraps the active values\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simplehabitatAE-Union{Tuple{C}, Tuple{Union{Float64, Unitful.Quantity{Float64,D,U} where U where D},Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,C,AbstractArray{#s188,2} where #s188<:Real}} where C<:Simulation.AbstractControl","page":"API","title":"Simulation.simplehabitatAE","text":"simplehabitatAE(\n    val::Union{Float64, Unitful.Quantity{Float64}},\n    area::Unitful.Area{Float64},\n    control::C,\n    initial_population::AbstractMatrix{<:Real},\n)\n\nCreate a simple ContinuousHab type epi environment from a specified initial_population matrix.\n\nInputs\n\nval: Fill the habitat with this value\ninitial_population: Used to derive the dimensions of the habitat, and the initial   susceptible population. Values in initial_population which are NaN or Missing are   used to mask off inactive areas. initial_population will be rounded to integers.\narea: The area of the habitat\ncontrol: The control to apply\n\nnote: Note\nThe simulation grid will be shrunk so that it tightly wraps the active values in initial_population.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simplenicheAE-Tuple{Int64,Tuple,Unitful.Quantity{Float64,D,U} where U where D,Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,Array{Bool,2}}","page":"API","title":"Simulation.simplenicheAE","text":"simplenicheAE(numniches::Int64, dimension::Tuple,\n                    maxBud::Float64, area::Unitful.Area{Float64},\n                    active::Array{Bool, 2})\n\nFunction to create a simple DiscreteHab, SimpleBudget type abiotic environment. Given a number of niche types numniches, it creates a DiscreteHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simulate!-Tuple{Simulation.AbstractEcosystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.simulate!","text":"simulate!(eco::Ecosystem, duration::Unitful.Time, interval::Unitful.Time,\n     timestep::Unitful.Time)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep'.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simulate!-Tuple{Simulation.AbstractEpiSystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.simulate!","text":"simulate!(\n    epi::AbstractEpiSystem,\n    duration::Unitful.Time,\n    timestep::Unitful.Time;\n    save=false,\n    save_path=pwd(),\n)\n\nRun an epidemiological system, epi, for specified length of times, duration, for a particular timestep, timestep. If save=true, inputs and outputs are saved as JLSO files at save_path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simulate_record!-Tuple{AbstractArray,Ecosystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.simulate_record!","text":"simulate_record!(eco::Ecosystem, duration::Unitful.Time, interval::Unitful.Time,\n     timestep::Unitful.Time)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep', and time interval for abundances to be recorded, interval. Optionally, there may also be a scenario by which the whole ecosystem is updated, such as removal of habitat patches.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simulate_record!-Tuple{AbstractArray,EpiSystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.simulate_record!","text":"simulate_record!(\n    storage::AbstractArray,\n    epi::EpiSystem,\n    times::Unitful.Time,\n    interval::Unitful.Time,\n    timestep::Unitful.Time;\n    save=false,\n    save_path=pwd(),\n)\n\nRun an epidemiological system, epi, for specified length of times, times, for a particular timestep, timestep, and time interval for abundances to be recorded, interval. Optionally, there may also be a scenario by which the whole ecosystem is updated, such as removal of habitat patches.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simulate_record_diversity!-Union{Tuple{F}, Tuple{AbstractArray,Ecosystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,SimpleScenario,F,Array{Float64,1}}} where F<:Function","page":"API","title":"Simulation.simulate_record_diversity!","text":"simulate_record_diversity!(storage::AbstractArray, eco::Ecosystem,\n  times::Unitful.Time, interval::Unitful.Time,timestep::Unitful.Time,\n  scenario::SimpleScenario, divfun::Function, qs::Float64)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep', and time interval for a diversity to be calculated and recorded, interval. Optionally, there may also be a scenario by which the whole ecosystem is updated, such as removal of habitat patches.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.sorenson-Tuple{Ecosystem,Array{Float64,1}}","page":"API","title":"Simulation.sorenson","text":"sorenson(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Sorenson similarity for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.tempgrad-Tuple{Union{Unitful.Quantity{Float64,ðš¯,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ðš¯,U}} where S where L} where U,Union{Unitful.Quantity{Float64,ðš¯,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ðš¯,U}} where S where L} where U,Union{Unitful.Quantity{Float64,ð‹,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹,U}} where S where L} where U,Tuple{Int64,Int64},Unitful.Quantity{Float64,ðš¯*ð“^-1,U} where U}","page":"API","title":"Simulation.tempgrad","text":"tempgrad(minT::Unitful.Temperature{Float64}, maxT::Unitful.Temperature{Float64},\n  size::Unitful.Length{Float64},\n  dim::Tuple{Int64, Int64}, rate::Quantity{Float64, ðš¯*ð“^-1})\n\nFunction to create a ContinuousHab habitat with a temperature gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.tempgradAE-Tuple{Union{Unitful.Quantity{Float64,ðš¯,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ðš¯,U}} where S where L} where U,Union{Unitful.Quantity{Float64,ðš¯,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ðš¯,U}} where S where L} where U,Tuple{Int64,Int64},Unitful.Quantity{Float64,D,U} where U where D,Union{Unitful.Quantity{Float64,ð‹^2,U}, Unitful.Level{L,S,Unitful.Quantity{Float64,ð‹^2,U}} where S where L} where U,Unitful.Quantity{Float64,ðš¯*ð“^-1,U} where U,Array{Bool,2}}","page":"API","title":"Simulation.tempgradAE","text":"tempgradAE(min::Unitful.Temperature{Float64},\n  max::Unitful.Temperature{Float64},\n  dimension::Tuple{Int64, Int64}, maxbud::Float64,\n  area::Unitful.Area{Float64}, rate::Quantity{Float64, typeof(ðš¯*ð“^-1)},\n  active::Array{Bool, 2})\n\nFunction to create a temperature gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max temperature, it generates a gradient from minimum at the bottom to maximum at the top. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.traitpopulate!-Union{Tuple{R}, Tuple{AB}, Tuple{GridLandscape,SpeciesList,AB,R}} where R<:Simulation.AbstractTraitRelationship where AB<:Simulation.AbstractAbiotic","page":"API","title":"Simulation.traitpopulate!","text":"traitpopulate!(ml::GridLandscape, spplist::SpeciesList,\n               abenv::AbstractAbiotic)\n\nFunction to populate a grid landscape given the abundances found in species list based upon how well the species traits match their environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.traitrepopulate!-Tuple{Ecosystem}","page":"API","title":"Simulation.traitrepopulate!","text":"repopulate!(eco::Ecosystem, abun::Int64)\n\nFunction to repopulate an ecosystem eco, with option for including trait preferences. An additional abun parameter can be included, in order to repopulate the ecosystem with a specified number of individuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.transition","page":"API","title":"Simulation.transition","text":"transition(params::SIRGrowth)\n\nFunction to create transition matrix from SIR parameters and return an EpiParams type that can be used by the model update.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.transition","page":"API","title":"Simulation.transition","text":"transition(params::SEIRGrowth)\n\nFunction to create transition matrix from SEIR parameters and return an EpiParams type that can be used by the model update.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.transition","page":"API","title":"Simulation.transition","text":"transition(params::SEI2HRDGrowth)\n\nFunction to create transition matrix from SEI2HRD parameters and return an EpiParams type that can be used by the model update.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.transition","page":"API","title":"Simulation.transition","text":"transition(params::SEIRSGrowth)\n\nFunction to create transition matrix from SEIRS parameters and return an EpiParams type that can be used by the model update.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.transition","page":"API","title":"Simulation.transition","text":"transition(params::SEI3HRDGrowth)\n\nFunction to create transition matrix from SEI2HRD parameters and return an EpiParams type that can be used by the model update.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.transition","page":"API","title":"Simulation.transition","text":"transition(params::SISGrowth)\n\nFunction to create transition matrix from SIS parameters and return an EpiParams type that can be used by the model update.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.update!-Tuple{Ecosystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.update!","text":"update!(eco::Ecosystem, time::Unitful.Time)\n\nFunction to update a ecosystem abundances and environment for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.update!-Tuple{EpiSystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.update!","text":"update!(epi::EpiSystem, time::Unitful.Time)\n\nFunction to update disease and virus class abundances and environment for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.worldclimAE-Tuple{Simulation.ClimatePref.Worldclim,Unitful.Quantity{Float64,D,U} where U where D}","page":"API","title":"Simulation.worldclimAE","text":"worldclimAE(wc::Worldclim, maxbud::Unitful.Quantity{Float64})\n\nFunction to create a ContinuousHab, SimpleBudget type abiotic environment from an Wordclim type climate. It either creates a SimpleBudget type filled with the maximum budget value maxbud or uses a provided budget of type SolarTimeBudget. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.worldclimChange-Tuple{Simulation.AbstractEcosystem,ContinuousTimeHab,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.worldclimChange","text":"worldclimChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to step the Worldclim climate forward by one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.AbstractAbiotic","page":"API","title":"Simulation.AbstractAbiotic","text":"AbstractAbiotic{H <: AbstractHabitat, B <: AbstractBudget} <: AbstractPartition\n\nAbstract supertype for all abiotic environment types and a subtype of AbstractPartition\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractBudget","page":"API","title":"Simulation.AbstractBudget","text":"AbstractBudget\n\nAbstract supertype for all budget types\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractControl","page":"API","title":"Simulation.AbstractControl","text":"AbstractControl\n\nAbstract type for all control strategies.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractEcosystem","page":"API","title":"Simulation.AbstractEcosystem","text":"AbstractEcosystem{Part <: AbstractAbiotic, SL <: SpeciesList,\n    TR <: AbstractTraitRelationship} <: AbstractMetacommunity{Float64,\n        Matrix{Int64}, Matrix{Float64}, SL, Part}\n\nAbstract supertype for all ecosystem types and a subtype of AbstractMetacommunity.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractEpiEnv","page":"API","title":"Simulation.AbstractEpiEnv","text":"AbstractEpiEnv{H <: AbstractHabitat, C <: AbstractControl} <:\nAbstractPartition{H}\n\nAbstract supertype for all epi environment types and a subtype of AbstractPartition.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractEpiSystem","page":"API","title":"Simulation.AbstractEpiSystem","text":"AbstractEpiSystem\n\nAbstract supertype for all disease system types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractHabitat","page":"API","title":"Simulation.AbstractHabitat","text":"AbstractHabitat\n\nAbstract supertype for all habitat types\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractMovement","page":"API","title":"Simulation.AbstractMovement","text":"AbstractMovement\n\nAbstract supertype of movements\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractParams","page":"API","title":"Simulation.AbstractParams","text":"AbstractParams\n\nAbstract supertype for all simulation parameter types\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractRequirement","page":"API","title":"Simulation.AbstractRequirement","text":"Abstract1Requirement{Energy}\n\nAbstract supertype for all species energy requirement types, parameterised by the type(s) of energy required Energy.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractScenario","page":"API","title":"Simulation.AbstractScenario","text":"AbstractScenario\n\nAbstract supertype for all whole ecosystem change scenarios\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractTraitRelationship","page":"API","title":"Simulation.AbstractTraitRelationship","text":"AbstractTraitRelationship{TR}\n\nThe abstract supertype of relationships between a trait and its environment, parameterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.AbstractTraits","page":"API","title":"Simulation.AbstractTraits","text":"AbstractTraits{T}\n\nAbstract supertype for all trait types, parameterised by traits of any type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.BoundaryCondition","page":"API","title":"Simulation.BoundaryCondition","text":"BoundaryCondition\n\nAn abstract type for what should happen at the boundaries of an ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Cache","page":"API","title":"Simulation.Cache","text":"Cache\n\nCache houses an integer array of moves made by all species in a timestep for the update! function, netmigration.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.ContinuousTrait","page":"API","title":"Simulation.ContinuousTrait","text":"ContinuousTrait{C <: Number} <: AbstractTraits{T}\n\nAbstract trait type that holds information on a single continuous trait for each species, of any Number type C.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.EpiParams","page":"API","title":"Simulation.EpiParams","text":"EpiParams{U <: Unitful.Units} <: AbstractParams\n\nParameter set for any epi model type, which stores information on birth, virus generation and decay probabilities, as well as matrices for transitions between different states. transition houses straightforward transition probabilities between classes, whereas transition_virus houses probabilities that should be multiplied by the amount of virus in the system, such as infection transitions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.HabitatUpdate","page":"API","title":"Simulation.HabitatUpdate","text":"ContinuousHab <: AbstractHabitat{Float64}\n\nThis habitat subtype has a matrix of floats and a float grid square size\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.HumanTypes","page":"API","title":"Simulation.HumanTypes","text":"HumanTypes{MO <: AbstractMovement,\n             T <: AbstractTypes} <: AbstractTypes\n\nHumanTypes holds information on the human disease classes, such as the name of each class, their initial abundances and types, as well as how they disperse virus across the landscape.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.Lookup","page":"API","title":"Simulation.Lookup","text":"Lookup\n\nLookup houses information on x, y grid locations and the probability of occurrence at the location for the species in question p. pnew and moves are initially empty storage and written over by the movement step in update!(). pnew is the recalculated probability based on which directions are available and moves is the number of moves to that grid location in that step.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.VirusTypes","page":"API","title":"Simulation.VirusTypes","text":"VirusTypes{TR <: AbstractTraits,\n             T <: AbstractTypes} <: AbstractTypes\n\nVirusTypes holds information on the virus classes, such as the name of each class, their trait match to the environment, initial abundances and types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation.WaterBudget","page":"API","title":"Simulation.WaterBudget","text":"WaterBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of solar energy units, representing the energy budget of each subcommunity in the abiotic environment at a fixed point in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.isapprox-Tuple{Simulation.AbstractEpiSystem,Simulation.AbstractEpiSystem}","page":"API","title":"Base.isapprox","text":"isapprox(epi_1::AbstractEpiSystem, epi_2::AbstractEpiSystem; kwargs...)\n\nCompare two EpiSystems for approximate equality. Specifically, compares the EpiLandscapes of the two systems.\n\nKeyword arguments\n\nAnything to pass to Base.isapprox.\n\nnote: Note\nYou may want to pass in atol or rtol to loosen the equality tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.BM","page":"API","title":"Simulation.BM","text":"BM(T::Real, ÏƒÂ²::Float64, start::Float64, lab::String=\"\")\n\nFunction to evolve a Real value through Brownian motion, with a starting value,  start, and rate, ÏƒÂ².\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation.HabitatLoss-Tuple{Simulation.AbstractEcosystem,Simulation.AbstractHabitat,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.HabitatLoss","text":"HabitatLoss(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to destroy habitat for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.NoChange-Tuple{Simulation.AbstractEcosystem,Simulation.AbstractHabitat,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.NoChange","text":"NoChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to keep the habitat the same for one timestep of the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.RainfallChange-Tuple{Simulation.AbstractEcosystem,ContinuousHab,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.RainfallChange","text":"RainfallChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to change the rainfall for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation._construct_shrunk_matrix-Tuple{Array{T,2} where T,Any,Any}","page":"API","title":"Simulation._construct_shrunk_matrix","text":"_construct_shrunk_matrix\n\nConstruct a shrunk matrix by selecting certain rows and columns specified by row_idxs and col_idxs from AbstractMatrix M.\n\nReturn an AxisArray{T, 2}. The axes will be the selected subset of the original axes if M is an AxisArray. If M is a normal matrix, the axes of the returned AxisArray are the selected coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation._convert_population-Tuple{Array{#s27,2} where #s27<:Real,AbstractArray{Bool,2}}","page":"API","title":"Simulation._convert_population","text":"_convert_population\n\nConvert populatioin matrix to Int matrix by filling in the inactive area with 0 population and rounding the active area.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation._shrink_to_active-Tuple{AbstractArray{T,2} where T,AbstractArray{#s188,2} where #s188<:Bool}","page":"API","title":"Simulation._shrink_to_active","text":"_shrink_to_active(M::AbstractMatrix, active::AbstractMatrix{<:Bool})\n\nShrink the matrix M to the minimum rectangular region which contains all active cells, as defined by active. Returns the shrunk matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.applycontrols!-Tuple{Simulation.AbstractEpiSystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.applycontrols!","text":"applycontrols!(epi::EpiSystem, timestep::Unitful.Time)\n\nFunction to apply control strategies to an EpiSystem for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.budgetupdate!-Tuple{Simulation.AbstractEcosystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.budgetupdate!","text":"budgetupdate!(eco::AbstractEcosystem, timestep::Unitful.Time)\n\nFunction to update the budget of an ecosystem for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.calc_lookup_moves!-Tuple{NoBoundary,Int64,Int64,Int64,Simulation.AbstractEcosystem,Int64}","page":"API","title":"Simulation.calc_lookup_moves!","text":"calc_lookup_moves!(bound, x::Int64, y::Int64, sp::Int64, eco::Ecosystem, abun::Int64)\n\nFunction to calculate the number of moves taken by a species, sp, from a specific grid square location (x, y). There is a boundary condition, bound, which determines how the species can move across space (see AbstractBoundary). The total abundance of individuals is given in abun, which may be the number of births in the timestep, or total indiviuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.classupdate!-Tuple{EpiSystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.classupdate!","text":"classupdate!(epi::EpiSystem, timestep::Unitful.Time)\n\nFunction to update disease class abundances for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.combineTR-Tuple{Union{multiplicativeTR2, multiplicativeTR3}}","page":"API","title":"Simulation.combineTR","text":"combineTR\n\nFunction that combines the output of multiple trait relationships, which varies depending on whether multiplicative, additive etc.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.emptyepilandscape-Tuple{GridEpiEnv,EpiList}","page":"API","title":"Simulation.emptyepilandscape","text":"emptyepilandscape(epienv::GridEpiEnv, epilist::EpiList)\n\nFunction to create an empty EpiLandscape given a GridEpiEnv and a EpiList.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.emptygridlandscape-Tuple{GridAbioticEnv,SpeciesList}","page":"API","title":"Simulation.emptygridlandscape","text":"emptygridlandscape(gae::GridAbioticEnv, spplist::SpeciesList)\n\nFunction to create an empty GridLandscape given a GridAbioticEnv and a SpeciesList.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.energy_adjustment-Tuple{Simulation.AbstractEcosystem,Simulation.AbstractBudget,Int64,Int64}","page":"API","title":"Simulation.energy_adjustment","text":"energy_adjustment(eco::Ecosystem, bud::AbstractBudget, i::Int64, sp::Int64)\n\nFunction to calculate how much birth and death rates should be adjusted by, according to how much energy is available, bud, in the grid square, i, and how much energy the species, sp, requires.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.equalpop-Tuple{EqualPop,Any}","page":"API","title":"Simulation.equalpop","text":"equalpop(params::EqualPop, numspp)\n\nFunction that takes demographic parameters from type EqualPop and converts them into type PopGrowth based on the number of species (numspp).\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.genlookups-Tuple{Simulation.AbstractEpiEnv,GaussianKernel}","page":"API","title":"Simulation.genlookups","text":"genlookups(hab::AbstractHabitat, mov::GaussianMovement)\n\nFunction to generate lookup tables, which hold information on the probability of moving to neighbouring squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.genlookups-Tuple{Simulation.AbstractHabitat,GaussianKernel}","page":"API","title":"Simulation.genlookups","text":"genlookups(hab::AbstractHabitat, mov::GaussianMovement)\n\nFunction to generate lookup tables, which hold information on the probability of moving to neighbouring squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.getdimension-Tuple{Simulation.AbstractEcosystem}","page":"API","title":"Simulation.getdimension","text":"getdimension(eco::Ecosystem)\n\nFunction to extract dimension of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.getlookup-Tuple{Simulation.AbstractEcosystem,Int64}","page":"API","title":"Simulation.getlookup","text":"getlookup(eco::Ecosystem)\n\nFunction to extract movement lookup table of species from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.getrelationship-Union{Tuple{R}, Tuple{R,Symbol}} where R<:Simulation.AbstractTraitRelationship","page":"API","title":"Simulation.getrelationship","text":"getpref(traits::T, field::Symbol) where T <: AbstractTraits\n\nFunction to extract the trait relationship of all species in the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.habitatupdate!-Tuple{Simulation.AbstractEcosystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.habitatupdate!","text":"habitatupdate!(eco::AbstractEcosystem, timestep::Unitful.Time)\n\nFunction to update the habitat of an ecosystem for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.initialise_output_abuns-Tuple{Array,NamedTuple}","page":"API","title":"Simulation.initialise_output_abuns","text":"initialise_output_abuns(\n    abuns::Array,\n    axes::NamedTuple;\n    h5fn=joinpath(pwd(),\"abundances.h5\")\n)\n\nCreate an HDF5 file h5fn to store abundance. Preallocate a fix-sized array to store abundance for each compartment, grid location and timestep. Fill in values for compartments, grid locations and timesteps.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.move!-Tuple{Simulation.AbstractEcosystem,AlwaysMovement,Int64,Int64,Array{Int64,2},Int64}","page":"API","title":"Simulation.move!","text":"move!(eco::Ecosystem, ::AbstractMovement, i::Int64, sp::Int64, grd::Array{Int64, 2}, abun::Int64)\n\nFunction to calculate the movement of species sp from a given position in the landscape i, using the lookup table found in the Ecosystem and updating the movement patterns on a cached grid, grd. Optionally, a number of births can be provided, so that movement only takes place as part of the birth process, instead of the entire population\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.runscenario!-Tuple{Ecosystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T,SimpleScenario,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.runscenario!","text":"runscenario!(eco::Ecosystem, timestep::Unitful.Time, scenario::S, currentstep::Unitful.Time) where S <: AbstractScenario\n\nThis function runs any scenario type for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.simplehabitat-Tuple{Unitful.Quantity,Union{Unitful.Quantity{T,ð‹,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð‹,U}} where S where L} where U where T,Tuple{Int64,Int64}}","page":"API","title":"Simulation.simplehabitat","text":"simplehabitat(val::Unitful.Quantity, size::Unitful.Length,\ndim::Tuple{Int64, Int64})\n\nFunction to create a ContinuousHab habitat of dimension dim, with cell size and filled value, val.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.sum_pop-Tuple{Array{Int64,2},Int64}","page":"API","title":"Simulation.sum_pop","text":"sum_pop(M::Matrix{Int64}, i::Int64)\n\nFunction to sum a population matrix, M, without memory allocation, at a grid location i.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.tematch-Tuple{SpeciesList,Simulation.AbstractAbiotic}","page":"API","title":"Simulation.tematch","text":"tematch(sppl::SpeciesList, abenv::AbstractAbiotic)\n\nFunction to check that the types of a trait list and habitat list are the same for a species list (sppl) and abiotic environment (abenv).\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.traitfun-Tuple{Simulation.AbstractEcosystem,Int64,Int64}","page":"API","title":"Simulation.traitfun","text":"traitfun(eco::AbstractEcosystem, pos::Int64, sp::Int64)\n\nFunction to calculate relationship between the current environment and a species' particular trait.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.traitfun-Tuple{Simulation.AbstractEpiSystem,Int64,Int64}","page":"API","title":"Simulation.traitfun","text":"traitfun(epi::AbstractEpiSystem, pos::Int64, sp::Int64)\n\nFunction to calculate relationship between the current environment and a particular trait of a disease class.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.trmatch-Tuple{SpeciesList,Simulation.AbstractTraitRelationship}","page":"API","title":"Simulation.trmatch","text":"trmatch(sppl::SpeciesList, traitrel::AbstractTraitRelationship)\n\nFunction to check that the types of a trait list and trait relationship list are the same for a species list (sppl) and trait relationship (traitrel).\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.update_energy_usage!-Union{Tuple{Simulation.AbstractEcosystem{A,SpeciesList{Tr,Req,B,C,D},E}}, Tuple{Req}, Tuple{Tr}, Tuple{E}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}} where Req<:Simulation.Abstract1Requirement where Tr where E where D where C where B where A","page":"API","title":"Simulation.update_energy_usage!","text":"update_energy_usage!(eco::Ecosystem)\n\nFunction to calculate how much energy has been used up by the current species in each grid square in the ecosystem, eco. This function is parameterised on whether the species have one type of energy requirement or two.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.update_output_abuns-Tuple{Array{T,2} where T,Int64}","page":"API","title":"Simulation.update_output_abuns","text":"update_output_abuns(\n    abuns_t::Matrix,\n    timestep::Int;\n    h5fn=joinpath(pwd(),\"abundances.h5\")\n)\n\nUpdate the existing HDF5 file h5fn with the abundance matrix at a certain timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.virusmove!-Tuple{Simulation.AbstractEpiSystem,Int64,Int64,Array{Int64,2},Int64}","page":"API","title":"Simulation.virusmove!","text":"virusmove!(epi::AbstractEpiSystem, pos::Int64, id::Int64, grd::Array{Int64, 2}, newvirus::Int64)\n\nFunction to calculate the movement of force of infection id from a given position in the landscape pos, using the lookup table found in the EpiSystem and updating the movement patterns on a cached grid, grd. The number of new virus is provided, so that movement only takes place as part of the generation process.\n\n\n\n\n\n","category":"method"},{"location":"api/#Simulation.virusupdate!-Tuple{EpiSystem,Union{Unitful.Quantity{T,ð“,U}, Unitful.Level{L,S,Unitful.Quantity{T,ð“,U}} where S where L} where U where T}","page":"API","title":"Simulation.virusupdate!","text":"virusupdate!(epi::EpiSystem, time::Unitful.Time)\n\nFunction to update virus abundances and disperse for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"model_development/#Model-development-1","page":"Model Development","title":"Model development","text":"","category":"section"},{"location":"model_development/#Top-priorities-1","page":"Model Development","title":"Top priorities","text":"","category":"section"},{"location":"model_development/#","page":"Model Development","title":"Model Development","text":"Incorporate higher dimensionality in disease classes. I.e. Single susceptible category needs to be easily broken up into higher dimensions for infection category, age, gender, job type etc. This may involve a mapping between different array dimensions.\nTwo types of infection process from direct and indirect contact. Need to have an instantaneous infection pressure (from direct contact) that simulates aerosol transmission, which would be eliminated at the end of each step. Also have an environmental transmission which decays over time and has a lower transmission rate.  ","category":"page"},{"location":"model_development/#Further-developments-1","page":"Model Development","title":"Further developments","text":"","category":"section"},{"location":"model_development/#","page":"Model Development","title":"Model Development","text":"Add in household structure. This will include a more \"individual based\" model in which different ages and genders are tracked within a cell. However, timing of events is unlikely to be tracked as this is difficult to parallelise.\nAdd in different location types. E.g. schools, work, carehomes, general social situations (proxy for pubs, restaurants etc).\nRegionalisation. Working towards an 'irregular' grid structure. However, in the first instance, we could track information like health board or local authorities for each grid cell, and explore lockdown strategies among these different areas on a regular grid.\nVirus seasonality. There will be at least some seasonality with climate and other environmental information could also be considered, such as pollution levels.","category":"page"},{"location":"#Simulation.jl-1","page":"Home","title":"Simulation.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Simulation is a Julia package that provides functionality for simulating species undergoing dynamic biological processes such as birth, death, competition and dispersal, as well as environmental changes in climate and habitat. This branch has now been adapted to include basic functionality for spatially explicit, dynamic, stochastic SIR models.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The package was primarily developed for global scale simulations of plant biodiversity. The underlying model for this is described in the arXiv paper arXiv:1911.12257 (q-bio.QM) Dynamic virtual ecosystems as a tool for detecting large-scale responses of biodiversity to environmental and land-use change. Future updates to the package functionality involve incorporating age-structure and more complex epidemiological models.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This package is in alpha now, so please raise an issue if you find any problems.","category":"page"},{"location":"model_structure/#Model-structure-1","page":"Model Structure","title":"Model structure","text":"","category":"section"},{"location":"model_structure/#","page":"Model Structure","title":"Model Structure","text":"Description of the model as it currently stands.","category":"page"},{"location":"model_structure/#Epidemiology-1","page":"Model Structure","title":"Epidemiology","text":"","category":"section"},{"location":"model_structure/#","page":"Model Structure","title":"Model Structure","text":"We currently have an SEI3HRD compartmental model: Susceptible-Exposed-Asymptomatic-Presymptomatic-Symptomatic-Hospitalised-Recovered-Dead, as seen in Figure 1 below.","category":"page"},{"location":"model_structure/#Virus-update-loop-1","page":"Model Structure","title":"Virus update loop","text":"","category":"section"},{"location":"model_structure/#","page":"Model Structure","title":"Model Structure","text":"Virus grows as the sum of several Binomial draws from each infection category, NV_k c sim mathrmPoisson(f_c) where NV is new virus, k is the current grid square, c is the disease class, and f_c is the force of infection generation per disease class.\nThe force of infection is dependent on the population size of that disease class (P_ck), the growth parameter of that disease class (g_c), and the match of the virus to the environment at that location (T_k): f_c = g_c * P_ck * T_k\nThe virus decays similarly, according to a set probability d and the inverse match with environment (T_k^-1): Decayed virus sim mathrmBinomial(V_k d * T_k^-1)\nThe newly generated virus is distributed in space (i.e. grid square k rightarrow j) via a Gaussian kernel: D_c(kj)*NV_kc where D_c is a Gaussian kernel per infection class.\nCurrently, only the symptomatic and asymptomatic infectious classes can generate and spread virus, and f_c = 0 for all others.\nNewly generated virus infects other susceptibles either as an instantaneous force of infection (e.g. aerosol transmission) or through environmental transmission (e.g. through contact with a surface), both at separate rates. See below for more details.","category":"page"},{"location":"model_structure/#Disease-class-update-loop-1","page":"Model Structure","title":"Disease class update loop","text":"","category":"section"},{"location":"model_structure/#","page":"Model Structure","title":"Model Structure","text":"Birth/death per class: Susceptibles are born into the population at a set probability per class. There is also a background probability of death from each disease class.\nmathrmBirths_kc sim mathrmBinomial(P_kc b_c)\nmathrmDeaths_kc sim mathrmBinomial(P_kc d_c)\nTransitions per class: transitions between disease classes happen according to a transition matrix M, which are calculated as moves into the disease class from other categories: in_k c = sum_j^J mathrmBinomial(P_k j M_c j) where j in1J number of classes.\nM is constructed in advance and is altered for movement from Susceptible to Exposed categories by the amount of virus available in that location, V_k, or the instantaneous force of infection, F_k, which disappears at the end of each step.","category":"page"},{"location":"model_structure/#","page":"Model Structure","title":"Model Structure","text":"(Image: )","category":"page"},{"location":"model_structure/#","page":"Model Structure","title":"Model Structure","text":"Figure 1: Current model structure.","category":"page"},{"location":"model_structure/#Code-Structure-1","page":"Model Structure","title":"Code Structure","text":"","category":"section"},{"location":"model_structure/#","page":"Model Structure","title":"Model Structure","text":"The virus update loop happens first, parallelised over disease category. The virus must move between locations, so each process must have full access to the entire space. This will parallelise better when we have more disease categories, like age.\nThe disease class update loop happens second, parallelised over space. There is no movement between locations, but instead transitions between different categories.\nAn overall matrix housing the abundances per grid square and per disease category is housed in the EpiSystem, along with information on environment and a lookup table of moves between different grid squares for each kernel.\nAt every iteration of the update step, this matrix is updated in place to avoid additional memory allocation.","category":"page"}]
}
